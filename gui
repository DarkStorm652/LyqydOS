local function verifyAcyclicTable( t, track )	
	if type(t) == "table" then
		if track[t] ~= nil then
			return false
		end
		track[t] = true
		for k,v in pairs(t) do
			if not verifyAcyclicTable(v, track) then return false end
		end
	end
	return true
end

local function trackWindow(guiTable, targetWindow)
	if not guiTable.trackedWindows[targetWindow] then
		local windowTracked = false
		if guiTable.parentWindow == targetWindow then
			guiTable.trackedWindows[targetWindow] = {}
			windowTracked = true
		else
			for k,v in ipairs(guiTable.parentProcessTable.children) do
				if v == targetWindow then
					guiTable.trackedWindows[targetWindow] = {}
					windowTracked = true
				end
			end
		end
		if not windowTracked then return false end
	end
	return true
end

local guiElement = {
	setBounds = function(self, minX, minY, maxX, maxY)
		if minX < maxX and minY < maxY then
			self.bounds.minX = minX
			self.bounds.minY = minY
			self.bounds.maxX = maxX
			self.bounds.maxY = maxY
			return true
		end
		return false
	end,
	setVisible = function(self, visible)
		self.properties.isVisible = visible == true
	end,
	setEnabled = function(self, enable)
		self.properties.isEnabled = enable == true
	end,
	coordinatesWithinBounds = function(self, x, y)
		if x >= self.minX and x <= self.maxX and y >= self.minX and y <= self.maxY then
			return true
		else
			return false
		end
	end,
}

local emetatable = {__index = guiElement}

local function newGuiElement(guiInstance)
	local element = {
		bounds = {
			minX = 0,
			minY = 0,
			maxX = 1,
			maxY = 1,
		},
		properties = {
			isVisible = true,
			isEnabled = true,
		},
		parentWindow = guiInstance.parentWindow,
		parentInstance = guiInstance,
	}
	setmetatable(element, emetatable)
	return element
end


local guiTable = {
	newChildWindow = function(self, w, h, x, y, caption)
		local win = window.new(w, h, x, y, caption, process.windowCompositor:newBuffer())
		print(self.parentProcessID)
		process.addChildWindow(self.parentProcessID, win)
		return win
	end,

	--button gui element.  Used for clickable areas.
	newButton = function(self, minX, minY, maxX, maxY, labelTable, func, textColor, backgroundColor)
		local instance = newGuiElement(self)
		instance:setBounds(minX, minY, maxX, maxY)
		instance.data = {
			label = labelTable,
			func = func,
			textColor = textColor,
			backgroundColor = backgroundColor,
		}
		instance.draw = function(self)
			term.redirect(self.parentWindow.redirect)
			x, y = term.getSize()
			if self.bounds.minX >= 1 and self.bounds.minY >= 1 and self.bounds.maxX <= x and self.bounds.maxY <= y then
				term.setTextColor(self.data.textColor)
				term.setBackgroundColor(self.data.backgroundColor)
				for i = self.bounds.minY, self.bounds.maxY do
					term.setCursorPos(self.bounds.minX, i)
					term.write(self.data.label[i - self.bounds.minY + 1])
				end
			end
			term.restore()
		end
		instance.eventHandler = function(self, ...)
			local event = {...}
			if self.properties.isEnabled then
				if event[1] == "mouse_click" then
					if self.data.func then
						self.data.func()
					else
						return "lgui_button_click", self.label.name, self
					end
				end
			else
				return unpack(event)
			end
		end
		instance:draw()
		table.insert(self.trackedWindows[targetWindow].guiElements, instance)
		return instance
	end,

	--Menu gui element.  Used to generate a menu window from a table.
	newMenu = function(self, targetWindow, x, y, menuTable)
		if not verifyAcyclicTable(menuTable, {}) then return nil, "Cannot create cyclic menu" end
		if not trackWindow(self, targetWindow) then return nil, "Cannot create gui in menu parent window" end
		local elementData = {
			targetWindow = nil,
			menuEntries = {},
			cleanTable = {},
		}
		menuWidth = 0
		for i, v in ipairs(menuTable) do
			if type(v) == "table" then
				local entryData = {}
				entryData.name = v.name
				entryData.menu = v.options
				table.insert(elementData.menuEntries, entryData)
				table.insert(elementData.cleanTable, v.name)
				menuWidth = math.max(menuWidth, string.len(v.name))
			elseif type(v) == "string" then
				table.insert(elementData.menuEntries, {name = v})
				table.insert(elementData.cleanTable, v)
				menuWidth = math.max(menuWidth, string.len(v))
			end
		end
		local xLim, yLim = process.windowCompositor.x, process.windowCompositor.y
		--add one to get the borders accounted for
		if y + #elementData.menuEntries + 1 > yLim then
			y = math.max(1, yLim - #elementData.menuEntries - 1)
		end
		print(targetWindow.x + x..","..targetWindow.y + y..","..math.min(x + menuWidth + 1, xLim - x - 1)..","..math.min(yLim - 1, #elementData.menuEntries + 2))
		menuWindow = self:newChildWindow(math.min(x + menuWidth + 1, xLim - x - 1), math.min(yLim - 1, #elementData.menuEntries + 2), targetWindow.x + x, targetWindow.y + y, nil)
		elementData.targetWindow = menuWindow
		--menuWindow = window.new(targetWindow.x + x, targetWindow.y + y, math.min(x + menuWidth + 1, xLim - x - 1), math.min(yLim - 1, #elementData.menuEntries + 2), nil, process.windowCompositor:newBuffer())
		menuWindow:setDecorations("menu")
		--process.addChildWindow(self.parentProcessID, menuWindow)
		if not trackWindow(self, menuWindow) then
			menuWindow:destroy()
			return nil, "Cannot create gui in menu parent window"
		end
		elementData.offset = 1
		elementData.cursor = 1
		elementData.drawCursor = false
		elementData.draw = function(self)
			term.redirect(self.targetWindow)
			local xlim, ylim = term.getSize()
			if xlim < 3 or (ylim < 3 and #self.cleanTable > 2) then
				return nil, "Not enough space to draw menu!"
			end
			term.clear()
			term.setCursorPos(1, 1)
			if self.offset > 1 then
				term.write("/\\")
			else
				term.write(string.sub(self.cleanTable[1], 1, xlim))
			end
			for i=1, math.min(ylim - 2, #self.cleanTable - 1) do
				term.setCursorPos(1, i + 1)
				if self.drawCursor and self.offset + i == self.cursor then
					term.setBackgroundColor(colors.white)
					term.setTextColor(colors.black)
					term.write(string.sub(self.cleanTable[self.offset + i], 1, xlim))
					term.setBackgroundColor(colors.black)
					term.setTextColor(colors.white)
				else
					term.write(string.sub(self.cleanTable[self.offset + i], 1, xlim))
				end
			end
			if #self.cleanTable >= ylim then
				term.setCursorPos(1, ylim)
				if #self.cleanTable > self.offset + ylim - 1 then
					term.write("\\/")
				else
					if self.drawCursor and self.offset + i == self.cursor then
						term.setBackgroundColor(colors.white)
						term.setTextColor(colors.black)
						term.write(string.sub(self.cleanTable[#self.cleanTable], 1, xlim))
						term.setBackgroundColor(colors.black)
						term.setTextColor(colors.white)
					else
						term.write(string.sub(self.cleanTable[#self.cleanTable], 1, xlim))
					end
				end
			end
			term.restore()
		end
		elementData.eventHandler = function(self, ...)
			if event[1] == "key" then
				--up
				if event[2] == 200 then
					self.drawCursor = true
					if self.cursor - self.offset + 1 > 2 or (self.cursor > 1 and self.offset ==  1) then
						self.cursor = self.cursor - 1
						self.redrawMenu(self.cleanTable, self.cursor, self.offset, self.drawCursor)
					elseif self.cursor - self.offset + 1 == 2 and self.offset > 1 then
						self.offset = self.offset - 1
						self.cursor = self.cursor - 1
						self.redrawMenu(self.cleanTable, self.cursor, self.offset, self.drawCursor)
					end
				--down
				elseif event[2] == 208 then
					self.drawCursor = true
					_, ylim = term.getSize()
					if self.cursor < #self.cleanTable and (self.cursor - self.offset + 1 < ylim - 1 or #self.cleanTable <= ylim or (self.cursor == #self.cleanTable - 1 and self.cursor - self.offset + 1 == ylim - 1)) then
						self.cursor = self.cursor + 1
						self.redrawMenu(self.cleanTable, self.cursor, self.offset, self.drawCursor)
					elseif self.cursor < #self.cleanTable and self.cursor - self.offset + 1 == ylim - 1 then
						self.offset = self.offset + 1
						self.cursor = self.cursor + 1
						self.redrawMenu(self.cleanTable, self.cursor, self.offset, self.drawCursor)
					end
				elseif event[2] == 28 then
					return self.cursor
				end
			elseif event[1] == "mouse_click" and event[2] == 1 then
				if event[4] <= #self.cleanTable then
					_, ylim = term.getSize()
					if self.offset > 1 and event[4] == 1 then
						--scroll up.
						self.offset = self.offset - 1
						self.cursor = self.offset + 1
						self.redrawMenu(self.cleanTable, self.cursor, self.offset, self.drawCursor)
					elseif self.offset + ylim - 1 < #self.cleanTable and event[4] == ylim then
						--scroll down.
						self.offset = self.offset + 1
						self.cursor = self.offset + ylim - 2
						self.redrawMenu(self.cleanTable, self.cursor, self.offset, self.drawCursor)
					else
						self.drawCursor = true
						self.redrawMenu(self.cleanTable, self.cursor, self.offset, self.drawCursor)
						return event[4] + self.offset - 1
					end
				end
			elseif event[1] == "window_resize" then
				self.redrawMenu(self.cleanTable, self.cursor, self.offset, self.drawCursor)
			end
		end
		elementData:draw()
		return elementData
	end,

	--Menu Bar element.  Combination of buttons and menus, generated from a table.
	newMenuBar = function(self, targetWindow, x, y, menuTable)
		if not verifyAcyclicTable(menuTable, {}) then return nil, "Cannot create cyclic menu" end
		if not trackWindow(self, targetWindow) then return nil, "Cannot create gui in that window" end
		local elementData = {}
		elementData.menuButtons = {}
		
		local menuBarLength = 0
		for i, v in ipairs(menuTable) do
			if type(v) == "table" then
				--menu contains submenus, use .name for the text
				local buttonData = {}
				buttonData.name = v.name
				buttonData.menu = v.options
				table.insert(elementData.menuButtons, buttonData)
				menuBarLength = menuBarLength + string.len(v.name) + 1
			elseif type(v) == "string" then
				--menu option is just a button, use the text
				table.insert(elementData.menuButtons, {name = v})
				menuBarLength = menuBarLength + string.len(v) + 1
			end
		end
		menuBarLength = menuBarLength - 1
		local xLim, yLim = term.getSize()
		if menuBarLength <= xLim - (x - 1) then
			term.setCursorPos(x, y)
			for i=1, #elementData.menuButtons do
				term.write(elementData.menuButtons[i].name)
				if i < #elementData.menuButtons then
					term.write(" ")
				end
			end
		end

		elementData.minX = x
		elementData.minY = y
		elementData.maxX = x + menuBarLength - 1
		elementData.maxY = y
		elementData.eventHandler = function(self, ...)
			event = {...}
			if event[1] == "mouse_click" then
				local offset = 1
				for i,v in ipairs(self.menuButtons) do
					if event[3] >= offset and event[3] <= offset + string.len(v.name) - 1 then
						if v.options then
							--this creates the menu window
						else
							return "lgui_menu_click", v.name
						end
						--this button
						break
					else
						offset = offset + string.len(v.name) + 1
					end
				end
			end
		end
		if not self.trackedWindows[targetWindow].guiElements then self.trackedWindows[targetWindow].guiElements = {} end
		table.insert(self.trackedWindows[targetWindow].guiElements, elementData)
	end,
	handleEvent = function(self, ...)
		event = {...}
		if event[1] == "mouse_click" then
			local currentFront
			if not self.parentProcessTable.children or self.parentProcessTable.children[#self.parentProcessTable.children] == "rootWindow" then
				currentFront = self.parentWindow
			else
				currentFront = self.parentProcessTable.children[#self.parentProcessTable.children]
			end
			if not self.trackedWindows[currentFront] then
				return unpack(event)
			end
			--otherwise, we are tracking this window, so see if we clicked in a gui bounding box.
			if self.trackedWindows[currentFront].guiElements then
				for k, box in ipairs(self.trackedWindows[currentFront].guiElements) do
					if event[3] >= box.bounds.minX and event[3] <= box.bounds.maxX and event[4] >= box.bounds.minY and event[4] <= box.bounds.maxY then
						--event is in this bounding box!
						return box:eventHandler(event[1], event[2], event[3] - (box.minX - 1), event[4] - (box.minY - 1))
					end
				end
				--if it's not in our bounding boxes, return the event.
				return unpack(event)
			end
		elseif event[1] == "key" or event[1] == "char" then
			--check activation keys/current state
		end
		return unpack(event)
	end,
}

local gmetatable = {
	__index = guiTable,
}

function new()
	if not (process and compositor and window and process.activeProcess) then return nil, "Incorrect environment!" end
	local g = {
		parentProcessID = process.activeProcess,
		parentProcessTable = process.processTable[process.activeProcess],
		parentWindow = process.processTable[process.activeProcess].window,
		trackedWindows = {},
	}
	setmetatable( g, gmetatable )
	return g
end