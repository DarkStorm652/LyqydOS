local args = {...}
if #args < 1 then
	print("No program specified!")
else
	local startProcess = process.id()
	local lws = 1
	for pID, proc in pairs(process.processTable) do
		if proc.path == "lws" then
			lws = pID
			break
		end
	end
	path = shell.resolveProgram(table.remove(args, 1))
	if path then
		local w, h, x, y, max = 19, 9, 1, 1, "false"
		windowDimensions = {}
		winDims = io.open("/.lyqwin", "r")
		if winDims then
			for line in winDims:lines() do
				if string.match(line, "%d+,%d+,%d+,%d+,%a+,(.*)") == path then
					x, y, w, h, max = string.match(line, "(%d+),(%d+),(%d+),(%d+),(%a+),")
					break
				end
			end
			winDims:close()
		end
		local pTable = {}
		pTable.path = path
		pTable.queue = {}
		pTable.thread = coroutine.create(function() shell.run(path, unpack(args)) end)
		pTable.window = window.new(w, h, x, y, fs.getName(path), process.windowCompositor:newBuffer())
		if process.windowCompositor.target.isColor() then
			pTable.window:setType("standard")
			pTable.window:setDecorations("pretty")
		end
		if max == "true" then pTable.window:maximize() end
		table.insert(process.processTable, pTable)
		process.focusWindow = #process.processTable
		term.redirect(process.processTable[process.focusWindow].window.redirect)
		process.activeProcess = #process.processTable
		coroutine.resume(process.processTable[process.focusWindow].thread)
		process.activeProcess = startProcess
		term.restore()
		if coroutine.status(process.processTable[process.focusWindow].thread) == "dead" then
			peripheral.call("top", "write", "isdead")
			process.queueEvent(lws, "close_window", process.focusWindow)
			process.focusWindow = startProcess
		end
	end
end