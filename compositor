local function newRedirect(_compTable, _buffer)
	local redirect = {
		buffer = _buffer,
		compTable = _compTable
	}
	redirect.write = function(text)
		local pos = redirect.buffer.cursorX
		if pos + #text <= 1 then
			--skip entirely.
			redirect.buffer.cursorX = pos + #text
			return
		elseif pos < 1 then
			--adjust text to fit on screen starting at one.
			writeText = string.sub(text, math.abs(redirect.buffer.cursorX) + 2)
			redirect.buffer.cursorX = 1
		elseif pos >= redirect.compTable.x - 1 then
			--if we're off the edge to the right, skip entirely.
			redirect.buffer.cursorX = pos + #text
			return
		else
			writeText = text
		end
		redirect.buffer.text[redirect.buffer.cursorY] = string.sub(redirect.buffer.text[redirect.buffer.cursorY], math.min(1, redirect.buffer.cursorX - 1), redirect.buffer.cursorX - 1)..writeText..string.sub(redirect.buffer.text[redirect.buffer.cursorY], redirect.buffer.cursorX + string.len(writeText), redirect.compTable.x - 2)
		redirect.buffer.textColor[redirect.buffer.cursorY] = string.sub(redirect.buffer.textColor[redirect.buffer.cursorY], math.min(1, redirect.buffer.cursorX - 1), redirect.buffer.cursorX - 1)..string.rep(redirect.buffer.curTextColor, #writeText)..string.sub(redirect.buffer.textColor[redirect.buffer.cursorY], redirect.buffer.cursorX + string.len(writeText), redirect.buffer.w - 2)
		redirect.buffer.backColor[redirect.buffer.cursorY] = string.sub(redirect.buffer.backColor[redirect.buffer.cursorY], math.min(1, redirect.buffer.cursorX - 1), redirect.buffer.cursorX - 1)..string.rep(redirect.buffer.curBackColor, #writeText)..string.sub(redirect.buffer.backColor[redirect.buffer.cursorY], redirect.buffer.cursorX + string.len(writeText), redirect.buffer.w - 2)
		redirect.buffer.cursorX = pos + string.len(text)
		redirect.compTable:draw()
	end
	redirect.clear = function()
		for i=1, redirect.compTable.y do
			redirect.buffer.text[i] = string.rep(" ", redirect.compTable.x)
			redirect.buffer.textColor[i] = string.rep(redirect.buffer.curTextColor, redirect.compTable.x)
			redirect.buffer.backColor[i] = string.rep(redirect.buffer.curBackColor, redirect.compTable.x)
		end
		redirect.compTable:draw()
	end
	redirect.clearLine = function()
		redirect.buffer[redirect.buffer.cursorY] = string.rep(" ", redirect.compTable.x)
		redirect.buffer.textColor[redirect.buffer.cursorY] = string.rep(redirect.buffer.curTextColor, redirect.compTable.x)
		redirect.buffer.backColor[redirect.buffer.cursorY] = string.rep(redirect.buffer.curBackColor, redirect.compTable.x)
		redirect.compTable:draw()
	end
	redirect.getCursorPos = function()
		return redirect.buffer.cursorX, redirect.buffer.cursorY
	end
	redirect.setCursorPos = function(x, y)
		redirect.buffer.cursorX = math.floor(tonumber(x)) or redirect.buffer.cursorX
		redirect.buffer.cursorY = math.floor(tonumber(y)) or redirect.buffer.cursorY
		redirect.compTable:draw("cursor")
	end
	redirect.setCursorBlink = function(b)
		redirect.buffer.cursorBlink = b
		redirect.compTable:draw("cursor")
	end
	redirect.getSize = function()
		return redirect.compTable.x, redirect.compTable.y
	end
	redirect.scroll = function(n)
		for i=1, redirect.compTable.y - 1 do
			if redirect.buffer.text[i + n] then
				redirect.buffer.text[i] = redirect.buffer.text[i + n]
				redirect.buffer.textColor[i] = redirect.buffer.textColor[i + n]
				redirect.buffer.backColor[i] = redirect.buffer.backColor[i + n]
			end
		end
		for i=1,n do
			redirect.buffer.text[redirect.compTable.y - (1 + n)] = string.rep(" ", redirect.compTable.x)
			redirect.buffer.textColor[redirect.compTable.y - (1 + n)] = string.rep(redirect.buffer.curTextColor, redirect.compTable.x)
			redirect.buffer.backColor[redirect.compTable.y - (1 + n)] = string.rep(redirect.buffer.curBackColor, redirect.compTable.x)
		end
		redirect.compTable:draw()
	end
	redirect.setTextColor = function(clr)
		if clr and clr <= 32768 and clr >= 1 then
			if redirect.compTable.target.isColor() then
				redirect.buffer.curTextColor = string.format("%x", math.floor(math.log(clr) / math.log(2)))
			elseif clr == 1 or clr == 32768 then
				redirect.buffer.curTextColor = string.format("%x", math.floor(math.log(clr) / math.log(2)))
			else
				return nil, "Colour not supported"
			end
		end
	end
	redirect.setTextColour = redirect.setTextColor
	redirect.setBackgroundColor = function(clr)
		if clr and clr <= 32768 and clr >= 1 then
			if redirect.compTable.target.isColor() then
				redirect.buffer.curBackColor = string.format("%x", math.floor(math.log(clr) / math.log(2)))
			elseif clr == 32768 or clr == 1 then
				redirect.buffer.curBackColor = string.format("%x", math.floor(math.log(clr) / math.log(2)))
			else
				return nil, "Colour not supported"
			end
		end
	end
	redirect.setBackgroundColour = redirect.setBackgroundColor
	redirect.isColor = function()
		return redirect.compTable.target.isColor()
	end
	redirect.isColour = redirect.isColor
	redirect.render = function(win)
		if not win.minimized then
			for i=1, #redirect.buffer.text do
				if i == win.y then
					if win.caption then
						local caption = string.sub(win.caption, 1, win.w - 4)
						redirect.buffer.text[i] = string.rep(" ", win.x - 1)..win.decorations.ul..win.decorations.top..caption..string.rep(win.decorations.top, win.w - (string.len(caption) + 3))..win.decorations.ur..string.rep(" ", redirect.compTable.x - (win.x + win.w - 1))
					else
						redirect.buffer.text[i] = string.rep(" ", win.x - 1)..win.decorations.ul..string.rep(win.decorations.top, win.w - 2)..win.decorations.ur..string.rep(" ", redirect.compTable.x - (win.x + win.w - 1))
					end
					redirect.buffer.textColor[i] = string.rep("0", redirect.compTable.x)
					redirect.buffer.backColor[i] = string.rep("f", redirect.compTable.x)
					if win.windowType == "modal" then
						redirect.buffer.text[i] = string.sub(redirect.buffer.text[i], 1, win.x + win.w - 5).."-X"..string.sub(redirect.buffer.text[i], win.x + win.w - 2)
						if redirect.compTable.target.isColor() then redirect.buffer.textColor[i] = string.rep("0", win.x + win.w - 4).."e"..string.rep("0", redirect.compTable.x - (win.x + win.w - 3)) end
					elseif win.windowType == "standard" then
						if win.maximized then
							redirect.buffer.text[i] = string.sub(redirect.buffer.text[i], 1, win.x + win.w - 7).."-_RX"..string.sub(redirect.buffer.text[i], win.x + win.w - 2)
						else
							redirect.buffer.text[i] = string.sub(redirect.buffer.text[i], 1, win.x + win.w - 7).."-_MX"..string.sub(redirect.buffer.text[i], win.x + win.w - 2)
						end
						if redirect.compTable.target.isColor() then redirect.buffer.textColor[i] = string.rep("0", win.x + win.w - 4).."e"..string.rep("0", redirect.compTable.x - (win.x + win.w - 3)) end
					end
				elseif i > win.y and i < win.y + win.h - 1 then
					redirect.buffer.text[i] = string.rep(" ", win.x - 1)..win.decorations.left..string.sub(win.buffer.text[i - win.y], 1, win.w - 2)..win.decorations.right..string.rep(" ", redirect.compTable.x - (win.x + win.w - 1))
					--initial -1 isn't necessary, to catch leading window decoration, trailing edge uses -2 to pick up the window decoration as well.
					redirect.buffer.textColor[i] = string.rep("0", win.x)..string.sub(win.buffer.textColor[i - win.y], 1, win.w - 2)..string.rep("0", redirect.compTable.x - (win.x + win.w - 2))
					redirect.buffer.backColor[i] = string.rep("f", win.x)..string.sub(win.buffer.backColor[i - win.y], 1, win.w - 2)..string.rep("f", redirect.compTable.x - (win.x + win.w - 2))
				elseif i == win.y + win.h - 1 then
					redirect.buffer.text[i] = string.rep(" ", win.x - 1)..win.decorations.ll..string.rep(win.decorations.bottom, win.w - 2)..win.decorations.lr..string.rep(" ", redirect.compTable.x - (win.x + win.w - 1))
					redirect.buffer.textColor[i] = string.rep("0", redirect.compTable.x)
					redirect.buffer.backColor[i] = string.rep("f", redirect.compTable.x)
				else
					redirect.buffer.text[i] = string.rep(" ", redirect.compTable.x)
					redirect.buffer.textColor[i] = string.rep("0", redirect.compTable.x)
					redirect.buffer.backColor[i] = string.rep("f", redirect.compTable.x)
				end
			end
		else
			for i=1, #redirect.buffer.text do
				redirect.buffer.text[i] = string.rep(" ", redirect.compTable.x)
				redirect.buffer.textColor[i] = string.rep("0", redirect.compTable.x)
				redirect.buffer.backColor[i] = string.rep("f", redirect.compTable.x)
			end
		end
		redirect.buffer.cursorX = win.x + win.cursorX
		redirect.buffer.cursorY = win.y + win.cursorY
		if not win.minimized then redirect.buffer.cursorBlink = win.cursorBlink else redirect.buffer.cursorBlink = false end
		redirect.buffer.minX = win.x
		redirect.buffer.maxX = win.x + win.w - 1
		redirect.buffer.minY = win.y
		redirect.buffer.maxY = win.y + win.h - 1
		redirect.compTable:draw()
	end
	redirect.setBounds = function(x_min, y_min, x_max, y_max)
		redirect.buffer.minX = x_min
		redirect.buffer.maxX = x_max
		redirect.buffer.minY = y_min
		redirect.buffer.maxY = y_max
	end
	return redirect
end

local compositor = {
	newBuffer = function(self)
		local buffer = {cursorX = 1, cursorY = 1, cursorBlink = false, text = {}, textColor = {}, backColor = {}, curTextColor = "0", curBackColor = "f", minX = 1, minY = 1, maxX = self.x, maxY = self.y}
		for i=1, self.y do
			buffer.text[i] = string.rep(" ", self.x)
			buffer.textColor[i] = string.rep("0", self.x)
			buffer.backColor[i] = string.rep("f", self.x)
		end
		table.insert(self.bufferStack, buffer)
		return newRedirect(self, buffer)
	end,
	draw = function(self, mode, ...)
		args = {...}
		term.redirect(self.target)
		term.setCursorBlink(false)
		if mode ~= "cursor" then
			local finalBuffer = {text = {}, textColor = {}, backColor = {}}
			for i=1, self.y do
				finalBuffer.text[i] = string.rep(" ", self.x)
				finalBuffer.textColor[i] = string.rep("0", self.x)
				finalBuffer.backColor[i] = string.rep("f", self.x)
			end
			for i=1, #self.bufferStack do
				local j = self.bufferStack[i].minY
				repeat
					finalBuffer.text[j] = string.sub(string.sub(finalBuffer.text[j], math.min(1, self.bufferStack[i].minX - 1), self.bufferStack[i].minX - 1)..string.sub(self.bufferStack[i].text[j], self.bufferStack[i].minX, self.bufferStack[i].maxX)..string.sub(finalBuffer.text[j], self.bufferStack[i].maxX + 1, self.x), 1, self.x)
					finalBuffer.textColor[j] = string.sub(string.sub(finalBuffer.textColor[j], math.min(1, self.bufferStack[i].minX - 1), self.bufferStack[i].minX - 1)..string.sub(self.bufferStack[i].textColor[j], self.bufferStack[i].minX, self.bufferStack[i].maxX)..string.sub(finalBuffer.textColor[j], self.bufferStack[i].maxX + 1, self.x), 1, self.x)
					finalBuffer.backColor[j] = string.sub(string.sub(finalBuffer.backColor[j], math.min(1, self.bufferStack[i].minX - 1), self.bufferStack[i].minX - 1)..string.sub(self.bufferStack[i].backColor[j], self.bufferStack[i].minX, self.bufferStack[i].maxX)..string.sub(finalBuffer.backColor[j], self.bufferStack[i].maxX + 1, self.x), 1, self.x)
					j = j + 1
				until j > self.bufferStack[i].maxY
			end
			for i=1, self.y do
				term.setCursorPos(1,i)
				if finalBuffer.text[i] ~= self.currentBuffer.text[i] or finalBuffer.textColor[i] ~= self.currentBuffer.textColor[i] or finalBuffer.backColor[i] ~= self.currentBuffer.backColor[i] then
					local lineEnd = false
					local offset = 1
					while not lineEnd do
						local textColorString = string.match(string.sub(finalBuffer.textColor[i], offset), string.sub(finalBuffer.textColor[i], offset, offset).."*")
						local backColorString = string.match(string.sub(finalBuffer.backColor[i], offset), string.sub(finalBuffer.backColor[i], offset, offset).."*")
						term.setTextColor(2 ^ tonumber(string.sub(textColorString, 1, 1), 16))
						term.setBackgroundColor(2 ^ tonumber(string.sub(backColorString, 1, 1), 16))
						term.write(string.sub(finalBuffer.text[i], offset, offset + math.min(#textColorString, #backColorString) - 1))
						offset = offset + math.min(#textColorString, #backColorString)
						if offset > self.x then lineEnd = true end
					end
				end
				self.currentBuffer.text[i] = finalBuffer.text[i]
				self.currentBuffer.textColor[i] = finalBuffer.textColor[i]
				self.currentBuffer.backColor[i] = finalBuffer.backColor[i]
			end
		end
		term.setCursorPos(self.bufferStack[#self.bufferStack].cursorX, self.bufferStack[#self.bufferStack].cursorY)
		term.setCursorBlink(self.bufferStack[#self.bufferStack].cursorBlink)
		term.restore()
	end,
	toFront = function(self, win)
		local pos = nil
		for i = 1, #self.bufferStack do
			if self.bufferStack[i] == win.target.buffer then
				pos = i
				break
			end
		end
		if pos and pos < #self.bufferStack then
			tempbuffer = self.bufferStack[pos]
			for i = pos, #self.bufferStack - 1 do
				self.bufferStack[i] = self.bufferStack[i + 1]
			end
			self.bufferStack[#self.bufferStack] = tempbuffer
			self:draw()
		end
	end,
	removeWindow = function(self, win)
		local pos = nil
		for i = 1, #self.bufferStack do
			if self.bufferStack[i] == win.target.buffer then
				pos = i
				break
			end
		end
		if pos then
			table.remove(self.bufferStack, pos)
			self:draw()
		end
	end,
}

local cmetatable = {
	__index = compositor,
}

function new(target)
	local comp = {
		bufferStack = {},
		target = target or term.native,
		currentBuffer = {text = {}, textColor = {}, backColor = {}}
	}
	setmetatable( comp, cmetatable )
	if comp.target.getSize() then
		comp.x, comp.y = comp.target.getSize()
	else
		return nil
	end
	for i=1, comp.y do
		comp.currentBuffer.text[i] = string.rep(" ", comp.x)
		comp.currentBuffer.textColor[i] = string.rep("0", comp.x)
		comp.currentBuffer.backColor[i] = string.rep("f", comp.x)
	end
	return comp
end