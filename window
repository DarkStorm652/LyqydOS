decorationsTable = {
	standard = {
		ul = "+",
		ur = "+",
		ll = "+",
		lr = "+",
		top = "-",
		bottom = "-",
		left = "|",
		right = "|",
	},
	menu = {
		ul = "/",
		ur = "\\",
		ll = "\\",
		lr = "/",
		top = "-",
		bottom = "-",
		left = "|",
		right = "|",
	},
}

local function newRedirect(_windowTable)
	local redirect = {windowTable = _windowTable}
	redirect.write = function(text)
		local pos = redirect.windowTable.cursorX
		if pos + #text <= 1 then
			--skip entirely.
			redirect.windowTable.cursorX = pos + #text
			return
		elseif pos < 1 then
			--adjust text to fit on screen starting at one.
			writeText = string.sub(text, math.abs(redirect.windowTable.cursorX) + 2)
			redirect.windowTable.cursorX = 1
		elseif pos >= redirect.windowTable.w - 1 then
			--if we're off the edge to the right, skip entirely.
			redirect.windowTable.cursorX = pos + #text
			return
		else
			writeText = text
		end
		redirect.windowTable.buffer.text[redirect.windowTable.cursorY] = string.sub(redirect.windowTable.buffer.text[redirect.windowTable.cursorY], math.min(1, redirect.windowTable.cursorX - 1), redirect.windowTable.cursorX - 1)..writeText..string.sub(redirect.windowTable.buffer.text[redirect.windowTable.cursorY], redirect.windowTable.cursorX + string.len(writeText), redirect.windowTable.w - 2)
		redirect.windowTable.buffer.textColor[redirect.windowTable.cursorY] = string.sub(redirect.windowTable.buffer.textColor[redirect.windowTable.cursorY], math.min(1, redirect.windowTable.cursorX - 1), redirect.windowTable.cursorX - 1)..string.rep(redirect.windowTable.buffer.curTextColor, #writeText)..string.sub(redirect.windowTable.buffer.textColor[redirect.windowTable.cursorY], redirect.windowTable.cursorX + string.len(writeText), redirect.windowTable.w - 2)
		redirect.windowTable.buffer.backColor[redirect.windowTable.cursorY] = string.sub(redirect.windowTable.buffer.backColor[redirect.windowTable.cursorY], math.min(1, redirect.windowTable.cursorX - 1), redirect.windowTable.cursorX - 1)..string.rep(redirect.windowTable.buffer.curBackColor, #writeText)..string.sub(redirect.windowTable.buffer.backColor[redirect.windowTable.cursorY], redirect.windowTable.cursorX + string.len(writeText), redirect.windowTable.w - 2)
		redirect.windowTable.cursorX = pos + string.len(text)
		redirect.windowTable:draw()
	end
	redirect.clear = function()
		for i=1, redirect.windowTable.h - 2 do
			redirect.windowTable.buffer.text[i] = string.rep(" ", redirect.windowTable.w - 2)
			redirect.windowTable.buffer.textColor[i] = string.rep(redirect.windowTable.buffer.curTextColor, redirect.windowTable.w - 2)
			redirect.windowTable.buffer.backColor[i] = string.rep(redirect.windowTable.buffer.curBackColor, redirect.windowTable.w - 2)
		end
		redirect.windowTable:draw()
	end
	redirect.clearLine = function()
		redirect.windowTable.buffer.text[redirect.windowTable.cursorY] = string.rep(" ", redirect.windowTable.w - 2)
		redirect.windowTable.buffer.textColor[redirect.windowTable.cursorY] = string.rep(redirect.windowTable.buffer.curTextColor, redirect.windowTable.w - 2)
		redirect.windowTable.buffer.backColor[redirect.windowTable.cursorY] = string.rep(redirect.windowTable.buffer.curBackColor, redirect.windowTable.w - 2)
		redirect.windowTable:draw()
	end
	redirect.getCursorPos = function()
		return redirect.windowTable.cursorX, redirect.windowTable.cursorY
	end
	redirect.setCursorPos = function(x, y)
		redirect.windowTable.cursorX = math.floor(tonumber(x)) or redirect.windowTable.cursorX
		redirect.windowTable.cursorY = math.floor(tonumber(y)) or redirect.windowTable.cursorY
		redirect.windowTable:draw("curosr")
	end
	redirect.setCursorBlink = function(b)
		redirect.windowTable.cursorBlink = b
		redirect.windowTable:draw("cursor")
	end
	redirect.getSize = function()
		return redirect.windowTable.w - 2, redirect.windowTable.h - 2
	end
	redirect.scroll = function(n)
		for i=1, redirect.windowTable.h - 3 do
			if redirect.windowTable.buffer.text[i + n] then
				redirect.windowTable.buffer.text[i] = redirect.windowTable.buffer.text[i + n]
				redirect.windowTable.buffer.textColor[i] = redirect.windowTable.buffer.textColor[i + n]
				redirect.windowTable.buffer.backColor[i] = redirect.windowTable.buffer.backColor[i + n]
			end
		end
		for i=1,n do
			redirect.windowTable.buffer.text[redirect.windowTable.h - (1 + n)] = string.rep(" ", redirect.windowTable.w - 2)
			redirect.windowTable.buffer.textColor[redirect.windowTable.h - (1 + n)] = string.rep(redirect.windowTable.buffer.curTextColor, redirect.windowTable.w - 2)
			redirect.windowTable.buffer.backColor[redirect.windowTable.h - (1 + n)] = string.rep(redirect.windowTable.buffer.curBackColor, redirect.windowTable.w - 2)
		end
		redirect.windowTable:draw()
	end
	redirect.setTextColor = function(clr)
		if clr and clr <= 32768 and clr >= 1 then
			if redirect.windowTable.target.isColor() then
				redirect.windowTable.buffer.curTextColor = string.format("%x", math.floor(math.log(clr) / math.log(2)))
			elseif clr == 1 or clr == 32768 then
				redirect.windowTable.buffer.curTextColor = string.format("%x", math.floor(math.log(clr) / math.log(2)))
			else
				return nil, "Colour not supported"
			end
		end
	end
	redirect.setTextColour = redirect.setTextColor
	redirect.setBackgroundColor = function(clr)
		if clr and clr <= 32768 and clr >= 1 then
			if redirect.windowTable.target.isColor() then
				redirect.windowTable.buffer.curBackColor = string.format("%x", math.floor(math.log(clr) / math.log(2)))
			elseif clr == 32768 or clr == 1 then
				redirect.windowTable.buffer.curBackColor = string.format("%x", math.floor(math.log(clr) / math.log(2)))
			else
				return nil, "Colour not supported"
			end
		end
	end
	redirect.setBackgroundColour = redirect.setBackgroundColor
	redirect.isColor = function()
		return redirect.windowTable.target.isColor()
	end
	redirect.isColour = redirect.isColor
	return redirect
end

local window = {
	draw = function(self, mode)
		if mode == "cursor" then
			term.redirect(self.target)
			term.setCursorPos(self.x + self.cursorX, self.y + self.cursorY)
			term.setCursorBlink(self.cursorBlink)
			term.restore()
		else
			if not self.target.render then
				if not self.minimized then
					term.redirect(self.target)
					term.clear()
					local top = nil
					if self.caption then
						if string.len(self.caption) > self.w - 4 then
							top = self.decorations.ul..self.decorations.top..string.sub(self.caption, 1, self.w - 4)
						else
							top = self.decorations.ul..self.decorations.top..self.caption
						end
						top = top..string.rep(self.decorations.top, self.w - (string.len(top) + 1))..self.decorations.ur
					else
						top = self.decorations.ul..string.rep(self.decorations.top, self.w - 2)..self.decorations.ur
					end
					term.setCursorPos(self.x, self.y)
					term.setTextColor(1)
					term.setBackgroundColor(32768)
					term.write(top)
					if self.windowType == "modal" or self.windowType == "standard" then
						term.setCursorPos(self.x + self.w - 4)
						term.write("-")
						if term.isColor() then term.setTextColor(16384) end
						term.write("X")
						term.setTextColor(1)
						if self.windowType == "standard" then
							term.setCursorPos(self.x + self.w - 6)
							if self.maximized then
								term.write("-_R")
							else
								term.write("-_M")
							end
						end
					end
					for i=1, self.h - 2 do
						term.setCursorPos(self.x, self.y + i)
						term.setTextColor(colors.white)
						term.setBackgroundColor(colors.black)
						term.write(self.decorations.left)
						for j=1, self.w - 2 do
							term.setTextColor(2 ^ tonumber(string.sub(self.buffer.textColor[i], j, j), 16))
							term.setBackgroundColor(2 ^ tonumber(string.sub(self.buffer.backColor[i], j, j), 16))
							term.write(string.sub(self.buffer.text[i], j, j))
						end
						term.setTextColor(colors.white)
						term.setBackgroundColor(colors.black)
						term.write(self.decorations.right)
					end
					term.setCursorPos(self.x, self.y + self.h - 1)
					term.write(self.decorations.ll..string.rep(self.decorations.bottom, self.w - 2)..self.decorations.lr)
					term.setCursorPos(self.x + self.cursorX, self.y + self.cursorY)
					term.setCursorBlink(self.cursorBlink)
					term.restore()
				end
			else
				self.target.render(self)
			end
		end
	end,
	move = function(self, x, y)
		if x and y then
			local xlim, ylim = self.target.getSize()
			if (x < 1 or x + self.w - 1 > xlim) and (y < 1 or y + self.h - 1 > ylim) then
				return nil, "location out of bounds"
			end
			if x >= 1 and x + self.w - 1 <= xlim then
				self.x = x
			end
			if y >= 1 and y + self.h - 1 <= ylim then
				self.y = y
			end
			self:draw()
			return true
		else
			return nil, "must specify x and y"
		end
	end,
	resize = function(self, w, h)
		if w and h then
			local w = tonumber(w)
			local h = tonumber(h)
			local xlim, ylim = self.target.getSize()
			if self.x + w - 1 > xlim or self.y + h - 1 > ylim then
				return nil, "window sized out of bounds"
			end
			if w >= 5 and h >= 3 then
				--adjust buffer horizontal size, but don't bother adjusting things below the new window bottom if smaller
				if w < self.w then
					for i=1, math.min(#self.buffer.text, math.max(self.h, h) - 2) do
						--w less two because the window border is part of the size, but not the buffer.
						self.buffer.text[i] = string.sub(self.buffer.text[i],1,w - 2)
						self.buffer.textColor[i] = string.sub(self.buffer.textColor[i],1,w - 2)
						self.buffer.backColor[i] = string.sub(self.buffer.backColor[i],1,w - 2)
					end
				elseif w > self.w then
					for i=1, math.min(#self.buffer.text, math.max(self.h, h) - 2) do
						--no need for width subtractions, since we are adjusting based on the difference between the two.
						self.buffer.text[i] = self.buffer.text[i]..string.rep(" ", w - self.w)
						self.buffer.textColor[i] = self.buffer.textColor[i]..string.rep(self.buffer.curTextColor, w - self.w)
						self.buffer.backColor[i] = self.buffer.backColor[i]..string.rep(self.buffer.curBackColor, w - self.w)
					end
				end
				self.w = w
				if h < self.h then
					repeat
					--remove the last entry to trim the buffer.
					table.remove(self.buffer.text)
					table.remove(self.buffer.textColor)
					table.remove(self.buffer.backColor)
					until #self.buffer.text == h - 2
				elseif h > self.h then
					repeat
						table.insert(self.buffer.text, string.rep(" ", self.w - 2))
						table.insert(self.buffer.textColor, string.rep(self.buffer.curTextColor, self.w - 2))
						table.insert(self.buffer.backColor, string.rep(self.buffer.curBackColor, self.w - 2))
					until #self.buffer.text == h - 2
				end
				self.h = h
				self:draw()
				return true
			else
				return nil, "size too small"
			end
		else
			return nil, "must specify width and height"
		end
	end,
	destroy = function(self)
		if self.target.compTable then
			self.target.compTable:removeWindow(self)
		end
		self = nil
	end,
	setDecorations = function(self, decoration)
		if not decoration then
			return nil, "Invalid decoration"
		elseif type(decoration) == "string" then
			if decorationsTable[decoration] then
				for k,v in pairs(decorationsTable[decoration]) do
					self.decorations[k] = string.sub(v, 1, 1)
				end
			else
				return nil, "Invalid decoration"
			end
		elseif type(decoration == "table") then
			for k,v in pairs(decorationsTable.standard) do
				--check for completeness.
				if type(decoration[k]) ~= "string" then
					return nil, "Invalid decoration"
				end
			end
			for k,v in pairs(decoration) do
				self.decorations[k] = v
			end
		else
			return nil, "Invalid decoration"
		end
		self:draw()
	end,
	maximize = function(self)
		self.normalSize = {x = self.x, y = self.y, w = self.w, h = self.h}
		self:move(1, 1)
		self.maximized = true
		self:resize(self.target.getSize())
	end,
	minimize = function(self)
		self.minimized = true
		self:draw()
	end,
	unMinimize = function(self)
		self.minimized = false
		self:draw()
	end,
	restore = function(self)
		self.maximized = false
		self:resize(self.normalSize.w, self.normalSize.h)
		self:move(self.normalSize.x, self.normalSize.y)
	end,
	setType = function(self, winType)
		self.windowType = winType
		self:draw()
	end,
	setCaption = function(self, text)
		self.caption = text
		self:draw()
	end,
}

local wmetatable = {
	__index = window,
}

function new(w, h, x, y, caption, target)
	local win = {
		buffer = {text = {}, textColor = {}, backColor = {}, curTextColor = "0", curBackColor = "f"},
		cursorX = 1,
		cursorY = 1,
		cursorBlink = false,
		target = target or term.native,
		w = tonumber(w) or 19,
		h = tonumber(h) or 8,
		x = tonumber(x) or 1,
		y = tonumber(y) or 1,
		caption = caption or nil,
		--windowType: clean, standard, modal
		--clean is normal window, standard includes _MX controls, modal includes X control only.
		windowType = "clean",
		decorations = {
			ul = "+",
			ur = "+",
			ll = "+",
			lr = "+",
			top = "-",
			bottom = "-",
			left = "|",
			right = "|",
		},
		maximized = false,
		minimized = false,
	}
	local xlim, ylim = win.target.getSize()
	--x and y bounding for initial window.
	if win.x < 1 then
		win.x = 1
	elseif win.x + win.w - 1 > xlim then
		win.x = xlim - win.w + 1
	end
	if win.y < 1 then
		win.y = 1
	elseif win.y + win.h - 1 > ylim then
		win.y = ylim - win.h + 1
	end
	win.redirect = newRedirect(win)
	for i=1, win.h-2 do
		win.buffer.text[i] = string.rep(" ", win.w - 2)
		win.buffer.textColor[i] = string.rep("0", win.w - 2)
		win.buffer.backColor[i] = string.rep("f", win.w - 2)
	end
	setmetatable( win, wmetatable )
	return win
end
