if fs.exists("/LyqydOS") and fs.isDir("/LyqydOS") then shell.setPath(shell.path()..":/LyqydOS") end

if not framebuffer then if fs.exists("/LyqydOS/framebuffer") then if not os.loadAPI("/LyqydOS/framebuffer") then print("Could not load framebuffer API!") return end else print("Could not find framebuffer API!") return end end
if not compositor then if fs.exists("/LyqydOS/compositor") then if not os.loadAPI("/LyqydOS/compositor") then print("Could not load compositor API!") return end else print("Could not find compositor API!") return end end
if not menu then if fs.exists("/LyqydOS/menu") then if not os.loadAPI("/LyqydOS/menu") then print("Could not load menu API!") return end else print("Could not find menu API!") return end end
if not process then if fs.exists("/LyqydOS/process") then if not os.loadAPI("/LyqydOS/process") then print("Could not load process API!") return end else print("Could not find process API!") return end end
if not window then if fs.exists("/LyqydOS/window") then if not os.loadAPI("/LyqydOS/window") then print("Could not load window API!") return end else print("Could not find window API!") return end end

if process.activeProcess ~= nil then return end

processTable = {}
process.focusWindow = nil
windowCompositor = compositor.new()
windowCompositor.deferDraw = true
rawset(process, "windowCompositor", windowCompositor)
rawset(process, "processTable", processTable)
do
	local x, y = term.getSize()
	process.nullRedirect = framebuffer.new(x, y, term.isColor())
end

local oldTredirect = term.redirect
local oldTrestore = term.restore

local function newTredirect(target)
	table.insert(process.redirectStack, target)
	oldTredirect(target)
end

local function newTrestore()
	table.remove(process.redirectStack)
	oldTrestore()
end

dofile(shell.resolveProgram("env"))

do
	local initPath = ""
	if fs.exists("/LyqydOS/.init") then
		initPath = "/LyqydOS/.init"
	else
		initPath = shell.resolveProgram(".init")
	end
	if #initPath > 0 then
		local handle = io.open(initPath, "r")
		if handle then
			for line in handle:lines() do
				process.add(function() shell.run(line) end, line)
			end
			handle:close()
		end
	end
end

local lws, desktop, lrnd

for k,v in pairs(process.processTable) do
	if v.path == "lws" then
		lws = k
	elseif v.path == "desktop" then
		desktop = k
	elseif v.path == "lrnd" then
		lrnd = k
	end
	if lws and desktop and lrnd then break end
end

windowDimensions = {}
winDims = io.open("/.lyqwin", "r")
if winDims then
	for line in winDims:lines() do
		local dimEntry = {}
		dimEntry.x, dimEntry.y, dimEntry.w, dimEntry.h, dimEntry.max, dimEntry.path = string.match(line, "(%d+),(%d+),(%d+),(%d+),(%a+),(.*)")
		if dimEntry.x and dimEntry.path then
			table.insert(windowDimensions, dimEntry)
		end
	end
	winDims:close()
end

local function checkWindow(pID)
	local proc = processTable[pID]
	if (proc and coroutine.status(proc.thread) == "dead") or (proc and proc.special and proc ~= processTable[process.focusWindow]) then
		if proc.window then
			if pID == desktop then
				--send terminate signal; pcall wrappers will allow current windows to close without killing process.
				process.queueEvent(desktop, "terminate")
			else
				process.queueEvent(lws, "close_window", pID)
			end
		end
		return false
	end
	return true
end

local function resumeProcess(pID, eventTable)
	--evaluate whether this event should even go to this process.
	if processTable[pID].listening then

		local resumeProcess = false
		for i=1, #processTable[pID].listening do
			if eventTable[1] == processTable[pID].listening[i] then
				resumeProcess = true
				processTable[pID].listening = nil
				break
			end
		end
		if not resumeProcess then return end
	end
	local redir = false
	--if process owns a window, set up its redirect functions.
	if processTable[pID].window then
		term.redirect(processTable[pID].window.redirect)
		redir = true
		if processTable[pID].redirectStack then
			for _,t in ipairs(processTable[pID].redirectStack) do
				term.redirect(t)
			end
		end
		rawset(term, "redirect", newTredirect)
		rawset(term, "restore", newTrestore)
	end
	process.activeProcess = pID
	passback = {coroutine.resume(processTable[pID].thread, unpack(eventTable))}
	windowCompositor:draw()
	process.activeProcess = nil
	--if the process had a window, recover its redirect stack and restore the redirect functions.
	if processTable[pID] then
		if redir then
			rawset(term, "redirect", oldTredirect)
			rawset(term, "restore", oldTrestore)
			processTable[pID].redirectStack = {}
			for i=1, #process.redirectStack do
				term.restore()
				processTable[pID].redirectStack[i] = process.redirectStack[i]
			end
			term.restore()
		end
		--handle filters being sent back in passback.
		if passback[1] and passback[2] then
			if type(passback[2]) == "string" then
				processTable[pID].listening = {passback[2]}
			elseif type(passback[2]) == "table" then
				processTable[pID].listening = passback[2]
			end
		end
	end
	--former checkProcess function.
	if not checkWindow(pID) then
		if pID == process.focusWindow then
			process.focusWindow = process.nextWindow(1)
			if processTable[process.focusWindow] then
				process.toFront(process.focusWindow)
			end
		end
	end
end

local function distributeEvent(event)
	if processTable[process.focusWindow] then
		resumeProcess(process.focusWindow, event)
	elseif event[1] == "key" or event[1] == "char" then
		if desktop then
			--events should fall through to desktop if there is no focus window.
			resumeProcess(desktop, event)
		end
	end
	--handle background processes.
	if event[1] ~= "key" and event[1] ~= "char" and event[1] ~= "mouse_click" and event[1] ~= "mouse_drag" and event[1] ~= "mouse_scroll" and event[1] ~= "window_resize" and event[1] ~= "terminate" then
		for tNum, tInfo in ipairs(processTable) do
			if tNum ~= process.focusWindow and tInfo then
				resumeProcess(tNum, event)
			end
		end
	end
end

--causes initial desktop and title bar to draw.
windowCompositor:draw()

local watchMouseDragging = false
local mouseStartX = nil
local mouseStartY = nil
local mouseDragAction = nil

while true do
	--process individually-queued events.
	for i=1, #processTable do
		checkWindow(i)
		if processTable[i] and processTable[i].queue and #processTable[i].queue >= 1 then
			repeat
				resumeProcess(i, table.remove(processTable[i].queue, 1))
			until #processTable[i].queue == 0
		end
	end
	--build title bar items.
	resumeProcess(desktop, {"redraw"})

	windowCompositor:draw()
	event = {coroutine.yield()}
	if event[1] == "key" and event[2] == 59 then
		--run menu for keyboard users.
		process.queueEvent(desktop, "run_program")
	elseif event[1] == "key" and event[2] == 61 then
		--window switching menu
		if process.focusWindow and process.processTable[process.focusWindow] then
			process.queueEvent(lws, "select_window")
		end
	elseif event[1] == "key" and event[2] == 62 then
		--window controls menu
		if process.focusWindow and process.processTable[process.focusWindow] then
			process.queueEvent(lws, "window_action", process.focusWindow, processTable[process.focusWindow].window)
		end
	elseif event[1] == "key" and event[2] == 63 then
		--full screen toggle

	elseif event[1] == "mouse_click" then
		watchMouseDragging = false
		local windowFound = false
		for i = #windowCompositor.bufferStack, 1, -1 do
			for pNum, pInfo in pairs(processTable) do
				if pInfo and pInfo.window and pInfo.window.target.buffer and pInfo.window.target.buffer == windowCompositor.bufferStack[i] then
					--correct window in order, break even if we don't get the click here.
					if event[3] >= pInfo.window.x and event[3] <= pInfo.window.x + pInfo.window.w - 1 and event[4] >= pInfo.window.y and event[4] <= pInfo.window.y + pInfo.window.h - 1 and not pInfo.window.minimized then
						windowFound = true
						if process.focusWindow ~= pNum then
							process.focusWindow = pNum
							process.toFront(process.focusWindow)
						end
						event[3] = event[3] - pInfo.window.x
						event[4] = event[4] - pInfo.window.y
						if event[3] > 0 and event[3] < pInfo.window.w - 1 and event[4] > 0 and event[4] < pInfo.window.h - 1 then
							--mouse click resume
							resumeProcess(process.focusWindow, event)
						elseif event[4] == 0 and event[2] == 2 then
							--right click on window title bar, open window menu.
							process.queueEvent(lws, "window_action", pNum, pInfo.window)
						elseif (pInfo.window.windowType == "modal" and event[4] == 0 and event[2] == 1 and pInfo.window.w - event[3] == 3) or (pInfo.window.windowType == "standard" and event[4] == 0 and event[2] == 1 and pInfo.window.w - event[3] > 2 and pInfo.window.w - event[3] < 6) then
							local action = pInfo.window.w - event[3] - 2
							if action == 1 then
								--close window
								process.queueEvent(lws, "close_window", process.focusWindow)
							elseif action == 2 then
								if pInfo.window.maximized then
									pInfo.window:restore()
									process.queueEvent(pNum, "window_resize")
								else
									pInfo.window:maximize()
									process.queueEvent(pNum, "window_resize")
								end
							elseif action == 3 then
								pInfo.window:minimize()
								process.toBack(pNum)
							end
						elseif event[4] == 0 and event[2] == 1 and not pInfo.special then
							--clicked on titlebar, set variables to see if we drag.
							watchMouseDragging = true
							mouseDragAction = "move"
							mouseStartX = event[3] + pInfo.window.x
							mouseStartY = event[4] + pInfo.window.y
						elseif event[3] == pInfo.window.w - 1 and event[4] == pInfo.window.h - 1 and event[2] == 1 and not pInfo.special then
							--clicked on lower right corner, resize.
							watchMouseDragging = true
							mouseDragAction = "resize"
							mouseStartX = event[3] + pInfo.window.x
							mouseStartY = event[4] + pInfo.window.y
						end
					end
					break
				end
			end
			if windowFound then break end
		end
		if not windowFound then
			--let desktop service handle this.
			resumeProcess(desktop, event)
		end
	elseif event[1] == "mouse_drag" then
		--mouse is dragging, see if we need to do something with windows.
		if watchMouseDragging then
			if mouseDragAction == "move" then
				processTable[process.focusWindow].window:move(processTable[process.focusWindow].window.x + (event[3] - mouseStartX), processTable[process.focusWindow].window.y + (event[4] - mouseStartY))
				mouseStartX = event[3]
				mouseStartY = event[4]
			elseif mouseDragAction == "resize" then
				processTable[process.focusWindow].window:resize(processTable[process.focusWindow].window.w + (event[3] - mouseStartX), processTable[process.focusWindow].window.h + (event[4] - mouseStartY))
				mouseStartX = event[3]
				mouseStartY = event[4]
				processTable[process.focusWindow].window.maximized = false
				process.queueEvent(process.focusWindow, "window_resize")
			end
		elseif processTable[process.focusWindow] and processTable[process.focusWindow].window then
			event[3] = event[3] - processTable[process.focusWindow].window.x
			event[4] = event[4] - processTable[process.focusWindow].window.y
			if event[3] > 0 and event[3] < processTable[process.focusWindow].window.w - 1 and event[4] > 0 and event[4] < processTable[process.focusWindow].window.h - 1 then
				resumeProcess(process.focusWindow, event)
			end
		elseif desktop then
			--fall through to desktop
			resumeProcess(desktop, event)
		end
	elseif event[1] == "mouse_scroll" then
		if processTable[process.focusWindow] and processTable[process.focusWindow].window then
			event[3] = event[3] - processTable[process.focusWindow].window.x
			event[4] = event[4] - processTable[process.focusWindow].window.y
			if event[3] > 0 and event[3] < processTable[process.focusWindow].window.w - 1 and event[4] > 0 and event[4] < processTable[process.focusWindow].window.h - 1 then
				resumeProcess(process.focusWindow, event)
			end
		elseif desktop then
			--fall through to desktop
			resumeProcess(desktop, event)
		end
	elseif event[1] == "modem_message" then
		if lrnd then
			process.queue(lrnd, unpack(event))
		else
			distributeEvent(event)
		end
	else
		distributeEvent(event)
	end
end
