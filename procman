processTable = {}
process.activeProcess = nil
windowCompositor = compositor.new()
rawset(process, "windowCompositor", windowCompositor)
rawset(process, "processTable", processTable)

local oldTredirect = term.redirect
local oldTrestore = term.restore

local function newTredirect(target)
	table.insert(process.redirectStack, target)
	oldTredirect(target)
end

local function newTrestore()
	table.remove(process.redirectStack)
	oldTrestore()
end

windowDimensions = {}
winDims = io.open("/.lyqwin", "r")
if winDims then
	for line in winDims:lines() do
		local dimEntry = {}
		dimEntry.x, dimEntry.y, dimEntry.w, dimEntry.h, dimEntry.path = string.match(line, "(%d+),(%d+),(%d+),(%d+),(.*)")
		if dimEntry.x and dimEntry.path then
			table.insert(windowDimensions, dimEntry)
		end
	end
	winDims:close()
end

local function nextWindow(default)
	if processTable[process.activeProcess] and processTable[process.activeProcess].parent then
		if processTable[processTable[process.activeProcess].parent] and processTable[processTable[process.activeProcess].parent].window then
			return processTable[process.activeProcess].parent
		end
	else
		local nextBuf = windowCompositor.bufferStack[#windowCompositor.bufferStack]
		local nextActive = default
		for tNum, tInfo in ipairs(processTable) do
			if tInfo and tInfo.window then
				if tInfo.window.target.buffer == nextBuf then
					nextActive = tNum
				end
			end
		end
		return nextActive
	end
end

local function saveDimensions(proc)
	if proc.path then
		local pathFound = false
		winDims = io.open("/.lyqwin", "w")
		if winDims then
			for wNum, wInfo in ipairs(windowDimensions) do
				if wInfo.path == proc.path then
					pathFound = true
					wInfo.x = proc.window.x
					wInfo.y = proc.window.y
					wInfo.w = proc.window.w
					wInfo.h = proc.window.h
				end
				winDims:write(wInfo.x..","..wInfo.y..","..wInfo.w..","..wInfo.h..","..wInfo.path.."\n")
			end
			if not pathFound then
				local winInfo = {}
				winInfo.x = proc.window.x
				winInfo.y = proc.window.y
				winInfo.w = proc.window.w
				winInfo.h = proc.window.h
				winInfo.path = proc.path
				table.insert(windowDimensions, winInfo)
				winDims:write(proc.window.x..","..proc.window.y..","..proc.window.w..","..proc.window.h..","..proc.path.."\n")
			end
			winDims:close()
		end
	end
end

local function checkWindow(proc)
	if (proc and coroutine.status(proc.thread) == "dead") or (proc and proc.special and proc ~= processTable[process.activeProcess]) then
		if proc.window then
			saveDimensions(proc)
			proc.window:destroy()
		end
		return false
	end
	return true
end

local function addChild(parent, child)
	if processTable[parent].children then
		local isChild = false
		for k, v in ipairs(processTable[parent].children) do
			if v == child then
				isChild = true
				break
			end
		end
		if not isChild then
			table.insert(processTable[parent].children, child)
		end
	else
		processTable[parent].children = {child}
	end
	processTable[child].parent = parent
end

local function selectWindow()
	local pList, menuList = {}, {}
	for tNum, tInfo in ipairs(process.processTable) do
		if tInfo and tInfo.window then
			table.insert(pList, tNum)
			table.insert(menuList, tInfo.window.caption)
		end
	end
	--removes self from list of running programs.
	table.remove(menuList)
	table.remove(pList)
	table.insert(menuList, "Cancel")
	local selection = menu.select(menuList)
	if pList[selection] then
		process.activeProcess = pList[selection]
		if processTable[process.activeProcess].window.minimized then processTable[process.activeProcess].window:unMinimize() end
		windowCompositor:toFront(processTable[process.activeProcess].window)
	end
end

local function startProgram()
	write("> ")
	local line = read()
	local args = {}
	for match in string.gmatch( line, "[^ \t]+" ) do
		table.insert( args, match )
	end
	path = shell.resolveProgram(table.remove(args, 1))
	if path then
		local w, h, x, y = 19, 9, 1, 1
		for dNum, dInfo in ipairs(windowDimensions) do
			if dInfo.path == path then
				w = dInfo.w
				h = dInfo.h
				x = dInfo.x
				y = dInfo.y
				break
			end
		end
		local pTable = {}
		pTable.path = path
		pTable.thread = coroutine.create(function() shell.run(path, unpack(args)) end)
		pTable.window = window.new(w, h, x, y, fs.getName(path), process.windowCompositor:newBuffer())
		if windowCompositor.target.isColor() then pTable.window:setType("standard") end
		table.insert(process.processTable, pTable)
		process.activeProcess = #process.processTable
		term.redirect(process.processTable[process.activeProcess].window.redirect)
		coroutine.resume(process.processTable[process.activeProcess].thread)
		term.restore()
	end
end

local function windowAction(actionProc)
	if processTable[actionProc] and processTable[actionProc].window then
		local selection = menu.select({"Move Window", "Resize Window", "Close Window", "Cancel"})
		return selection
	end
end

local function changeWindow(manipulationWindow, action)
	if action == 1 then
		--move
		while true do
			e, p1, p2, p3 = os.pullEvent()
			if e == "key" then
				if p1 == 200 then
					--up
					processTable[manipulationWindow].window:move(processTable[manipulationWindow].window.x, processTable[manipulationWindow].window.y - 1)
				elseif p1 == 203 then
					--left
					processTable[manipulationWindow].window:move(processTable[manipulationWindow].window.x - 1, processTable[manipulationWindow].window.y)
				elseif p1 == 205 then
					--right
					processTable[manipulationWindow].window:move(processTable[manipulationWindow].window.x + 1, processTable[manipulationWindow].window.y)
				elseif p1 == 208 then
					--down
					processTable[manipulationWindow].window:move(processTable[manipulationWindow].window.x, processTable[manipulationWindow].window.y + 1)
				elseif p1 == 28 then
					--enter
					break
				end
			elseif e == "mouse_click" and p1 == 1 then
				--mouse click
				processTable[manipulationWindow].window:move(p2, p3)
				break
			end
		end
	elseif action == 2 then
		--resize
		local newX, newY = processTable[manipulationWindow].window.x + processTable[manipulationWindow].window.w - 1, processTable[manipulationWindow].window.y + processTable[manipulationWindow].window.h - 1
		term.setCursorPos(newX, newY)
		term.write("*")
		term.setCursorPos(newX, newY)
		term.setCursorBlink(true)
		local xlim, ylim = windowCompositor.target.getSize()
		while true do
			e, p1, p2, p3 = os.pullEvent()
			term.setCursorBlink(false)
			if e == "key" then
				if p1 == 200 then
					--up
					if newY > processTable[manipulationWindow].window.y + 2 then
						windowCompositor.currentBuffer.text[newY] = string.sub(windowCompositor.currentBuffer.text[newY], 1, newX - 1).."*"..string.sub(windowCompositor.currentBuffer.text[newY], newX + 1)
						newY = newY - 1
					end
				elseif p1 == 203 then
					--left
					if newX > processTable[manipulationWindow].window.x + 4 then
						windowCompositor.currentBuffer.text[newY] = string.sub(windowCompositor.currentBuffer.text[newY], 1, newX - 1).."*"..string.sub(windowCompositor.currentBuffer.text[newY], newX + 1)
						newX = newX - 1
					end
				elseif p1 == 205 then
					--right
					if newX < xlim then
						windowCompositor.currentBuffer.text[newY] = string.sub(windowCompositor.currentBuffer.text[newY], 1, newX - 1).."*"..string.sub(windowCompositor.currentBuffer.text[newY], newX + 1)
						newX = newX + 1
					end
				elseif p1 == 208 then
					--down
					if newY < ylim then
						windowCompositor.currentBuffer.text[newY] = string.sub(windowCompositor.currentBuffer.text[newY], 1, newX - 1).."*"..string.sub(windowCompositor.currentBuffer.text[newY], newX + 1)
						newY = newY + 1
					end
				elseif p1 == 28 then
					--enter
					break
				end
				windowCompositor:draw()
				term.setCursorPos(newX, newY)
				term.write("*")
				term.setCursorPos(newX, newY)
				term.setCursorBlink(true)
			elseif e == "mouse_click" and p1 == 1 then
				if p2 > processTable[manipulationWindow].window.x + 4 and p3 > processTable[manipulationWindow].window.y + 2 then
					newX, newY = p2, p3
					break
				end
			end
		end
		processTable[manipulationWindow].window:resize(newX - processTable[manipulationWindow].window.x + 1, newY - processTable[manipulationWindow].window.y + 1)
		os.queueEvent("window_resize")
	elseif action == 3 then
		saveDimensions(processTable[manipulationWindow])
		processTable[manipulationWindow].window:destroy()
		processTable[manipulationWindow] = false
		process.activeProcess = nextWindow(1)
		if processTable[process.activeProcess] then
			windowCompositor:toFront(processTable[process.activeProcess].window)
		end
	end
end

local function checkProcess(passback)
	if not checkWindow(processTable[process.activeProcess]) then
		if processTable[process.activeProcess].special then
			if processTable[process.activeProcess].special == "window_action" then
				changeWindow(processTable[process.activeProcess].parent, passback[2])
			end
		end
		process.activeProcess = nextWindow(1)
		if processTable[process.activeProcess] then
			windowCompositor:toFront(processTable[process.activeProcess].window)
		end
	end
end

local function windowOptionsMenu()
	if processTable[process.activeProcess] then
		local pTable = {}
		local parent = process.activeProcess
		pTable.thread = coroutine.create(windowAction)
		pTable.window = window.new(17, 6, processTable[parent].window.x, processTable[parent].window.y, "Action Menu", windowCompositor:newBuffer())
		pTable.window:setDecorations("menu")
		table.insert(processTable, pTable)
		process.activeProcess = #processTable
		term.redirect(processTable[process.activeProcess].window.redirect)
		passback = {coroutine.resume(processTable[process.activeProcess].thread, parent)}
		term.restore()
		processTable[process.activeProcess].special = "window_action"
		addChild(parent, process.activeProcess)
	end
end

local function chooseWindowMenu()
	if processTable[process.activeProcess] then
		local pTable = {}
		pTable.thread = coroutine.create(selectWindow)
		pTable.window = window.new(19, 11, 1, 1, "Select Window", windowCompositor:newBuffer())
		table.insert(processTable, pTable)
		process.activeProcess = #process.processTable
		term.redirect(processTable[process.activeProcess].window.redirect)
		coroutine.resume(processTable[process.activeProcess].thread)
		term.restore()
		processTable[process.activeProcess].special = "select_window"
	end
end

term.clear()
local titlebar = windowCompositor:newBuffer()
local titlebarWidth, titlebarHeight = titlebar.getSize()
titlebar.buffer.text[1] = "=LyqydOS"..string.rep("=", titlebarWidth - 8)
windowCompositor:draw()

while true do
	local titlebarItems = {}
	for i=1, #processTable do
		if not checkWindow(processTable[i]) then
			processTable[i] = false
		else
			if processTable[i] and processTable[i].window and not processTable[i].special then
				local tBarEntry = {pID = i, text = processTable[i].window.caption}
				table.insert(titlebarItems, tBarEntry)
			end
		end
	end
	local taskText = ""
	local tasksClickable = 0
	local usableWidth = titlebarWidth - 10
	for eNum, eInfo in ipairs(titlebarItems) do
		if #taskText + 9 > usableWidth then
			if #taskText > 9 then
				taskText = string.sub(taskText, 1, -10).."More... |"
			end
			break
		end
		local str = string.sub(eInfo.text, 1, 8)
		str = str..string.rep(" ", 8 - #str)
		if taskText == "" then taskText = "|" end
		taskText = taskText..str.."|"
		tasksClickable = tasksClickable + 1
	end
	titlebar.buffer.text[1] = "=LyqydOS="..taskText..string.rep("=", titlebarWidth - (#taskText + 9))
	windowCompositor:draw()
	event = {coroutine.yield()}
	if event[1] == "key" and event[2] == 61 then
		--window switching menu
		chooseWindowMenu()
	elseif event[1] == "key" and event[2] == 62 then
		--window controls menu
		windowOptionsMenu()
	elseif event[1] == "mouse_click" then
		local windowFound = false
		for i = #windowCompositor.bufferStack, 1, -1 do
			for pNum, pInfo in pairs(processTable) do
				if pInfo and pInfo.window and pInfo.window.target.buffer == windowCompositor.bufferStack[i] then
					--correct window in order, break even if we don't get the click here.
					if event[3] >= pInfo.window.x and event[3] <= pInfo.window.x + pInfo.window.w - 1 and event[4] >= pInfo.window.y and event[4] <= pInfo.window.y + pInfo.window.h - 1 and not pInfo.window.minimized then
						windowFound = true
						if process.activeProcess ~= pNum then
							process.activeProcess = pNum
							windowCompositor:toFront(processTable[process.activeProcess].window)
						end
						event[3] = event[3] - pInfo.window.x
						event[4] = event[4] - pInfo.window.y
						if event[3] > 0 and event[3] < pInfo.window.w - 1 and event[4] > 0 and event[4] < pInfo.window.h - 1 then
							local redir = false
							if processTable[process.activeProcess].window then
								term.redirect(processTable[process.activeProcess].window.redirect)
								redir = true
							end
							passback = {coroutine.resume(processTable[process.activeProcess].thread, unpack(event))}
							if redir then term.restore() end
							checkProcess(passback)
						elseif event[4] == 0 and event[2] == 2 then
							--right click on window title bar, open window menu.
							windowOptionsMenu()
						elseif (pInfo.window.windowType == "modal" and event[4] == 0 and event[2] == 1 and pInfo.window.w - event[3] == 3) or (pInfo.window.windowType == "standard" and event[4] == 0 and event[2] == 1 and pInfo.window.w - event[3] > 2 and pInfo.window.w - event[3] < 6) then
							local action = pInfo.window.w - event[3] - 2
							if action == 1 then
								--close window
								saveDimensions(processTable[process.activeProcess])
								processTable[process.activeProcess].window:destroy()
								processTable[process.activeProcess] = false
								process.activeProcess = nextWindow(1)
								if processTable[process.activeProcess] then
									windowCompositor:toFront(processTable[process.activeProcess].window)
								end
							elseif action == 2 then
								if pInfo.window.maximized then
									pInfo.window:restore()
								else
									pInfo.window:maximize()
								end
							elseif action == 3 then
								pInfo.window:minimize()
							end
						end
					end
					break
				end
			end
			if windowFound then break end
		end
		if not windowFound and event[4] == 1 then
			--click on titlebar with no window covering it.
			if event[3] > 1 and event[3] < 9 and event[2] == 1 then
				--clicked on the LyqydOS button
				local pTable = {}
				pTable.thread = coroutine.create(startProgram)
				pTable.window = window.new(30, 3, 2, 2, "Run Program", windowCompositor:newBuffer())
				table.insert(processTable, pTable)
				process.activeProcess = #process.processTable
				term.redirect(processTable[process.activeProcess].window.redirect)
				coroutine.resume(processTable[process.activeProcess].thread)
				term.restore()
				processTable[process.activeProcess].special = "run_program"
			elseif event[3] > 9 then
				--clicked on task bar.
				clickItem = math.floor((event[3] - 1) / 9)
				if (event[3] - 10 ) % 9 ~= 0 and clickItem <= tasksClickable then
					--they clicked on the name itself, not the boundary line.
					if clickItem == tasksClickable and clickItem < #titlebarItems then
						--display the window choice dialog
						chooseWindowMenu()
					else
						if process.activeProcess ~= titlebarItems[clickItem].pID then
							process.activeProcess = titlebarItems[clickItem].pID
						end
						windowCompositor:toFront(processTable[process.activeProcess].window)
						if processTable[process.activeProcess].window.minimized then processTable[process.activeProcess].window:unMinimize() end
						if event[2] == 2 then
							--they right-clicked, so let's also display the window action menu.
							windowOptionsMenu()
						end
					end
				end
			end
		end
	else
		if processTable[process.activeProcess] then
			local redir = false
			if processTable[process.activeProcess].window then
				term.redirect(processTable[process.activeProcess].window.redirect)
				redir = true
				for _,t in ipairs(process.redirectStack) do
					term.redirect(t)
				end
				rawset(term, "redirect", newTredirect)
				rawset(term, "restore", newTrestore)
			end
			passback = {coroutine.resume(processTable[process.activeProcess].thread, unpack(event))}
			if redir then
				rawset(term, "redirect", oldTredirect)
				rawset(term, "restore", oldTrestore)
				for i=1, #process.redirectStack do
					term.restore()
				end
				term.restore()
			end
			checkProcess(passback)
		end
		--handle background processes.
		if event[1] ~= "key" and event[1] ~= "char" and event[1] ~= "mouse_click" and event ~= "window_resize" then
			for tNum, tInfo in ipairs(processTable) do
				if tInfo and tInfo.listening then
					for k, eType in ipairs(tInfo.listening) do
						if event[1] == eType then
							local redir = false
							if processTable[tNum].window then
								term.redirect(processTable[tNum].window.redirect)
								redir = true
							end
							passback = {coroutine.resume(processTable[tNum].thread, unpack(event))}
							if redir then term.restore() end
							if coroutine.status(processTable[tNum].thread) == "dead" then
								if processTable[tNum].window then
									processTable[tNum].window:destroy()
								end
							end
							break
						end
					end
				end
			end
		end
	end
end